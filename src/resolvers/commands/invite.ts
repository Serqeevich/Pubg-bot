import { computeChannelUsers } from '../../utils/helpers';
import { CommandResolver, NOTE_LIMIT_CHARS } from '.';
import { deleteAllLfsAuthorEmbeds, parseMessageRelatedToChannel } from '../../utils/embeds';
import { EmbedError } from '../../embeds/Error';
import User from '../../models/user';
import { LfsMessage } from '../../models/LfsMessage';

const LfsResolver: CommandResolver = async (client, message, argumentsParsed) => {
  if (message.channel.id !== process.env.LFS_CHANNEL_ID) return;

  await message.delete();
  const authorVoiceChannel = message.member?.voice.channel;
  // const isNoteValid = QUOTE_REGEX.test(argumentsParsed._[1]);
  const str = argumentsParsed._;
  str.shift();
  const note = str.join(' ') ?? '';

  if (note.length - 1 > NOTE_LIMIT_CHARS) {
    throw new EmbedError(
      `<@${message.author.id}> –≤—ã –º–æ–∂–µ—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç—å –Ω–µ –±–æ–ª–µ–µ 120 —Å–∏–º–≤–æ–ª–æ–≤ –≤ –∫–æ–º–∞–Ω–¥–µ \`!invite "–∏ –≤–∞—à –∫–æ–º–µ–Ω—Ç–∞—Ä–∏–π"\`.`,
    );
  }

  // delete previous lfs embeds
  const textChannel = await client.channels.fetch(process.env.LFS_CHANNEL_ID);
  if (textChannel.isText()) {
    const messages = await textChannel.messages.fetch();
    await deleteAllLfsAuthorEmbeds(message.author.id, messages);

    // should only create lfs if theres not one already related to the channel
    if (authorVoiceChannel?.id) {
      const updatedMessages = await textChannel.messages.fetch();
      const messagesArr = updatedMessages.map((m) => m);
      const embedOfChannel = parseMessageRelatedToChannel(messagesArr, authorVoiceChannel?.id);
      if (
        embedOfChannel?.embedParsed?.channel?.id &&
        embedOfChannel?.embedParsed?.channel?.id === authorVoiceChannel?.id
      )
        return;
    }

    // should only create lfs if less than 4 players in channel
    console.log('limit', authorVoiceChannel?.userLimit);
    console.log('authorVoiceChannel?.members?.size', authorVoiceChannel?.members?.size);
    if (
      authorVoiceChannel &&
      authorVoiceChannel?.userLimit > 0 &&
      authorVoiceChannel?.members?.size >= authorVoiceChannel?.userLimit
    ) {
      await message.member?.send('–í–∞—à –∫–∞–Ω–∞–ª —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω.');
      return;
    }
  }

  if (authorVoiceChannel && authorVoiceChannel.members.size > 0) {
    const authorVoiceChannelUsersDiscordIds = authorVoiceChannel?.members.map((member) => member.user.id);
    const channelUsersDocuments = await User.find({ discordId: { $in: authorVoiceChannelUsersDiscordIds } });
    const userLimit = authorVoiceChannel.userLimit;

    //TODO –º–Ω–æ–≥–æ –ª–∏—à–Ω–µ–≥–æ
    const users = computeChannelUsers(authorVoiceChannel?.members, channelUsersDocuments, message.author.id);

    const missingPlayersContent = userLimit ? users && users.length && ` +${userLimit - users.length}` : '';

    const footer = users?.length === userLimit ? '–ö–∞–Ω–∞–ª –∑–∞–ø–æ–ª–Ω–µ–Ω ‚õî' : `–í –ø–æ–∏—Å–∫–µ ${missingPlayersContent} –∏–≥—Ä–æ–∫–æ–≤`;

    const invite = authorVoiceChannel.full ? { url: '' } : await authorVoiceChannel?.createInvite();

    const missingPlayers = users ? userLimit - users.length : 0;
    const channel = {
      id: authorVoiceChannel.id,
      name: authorVoiceChannel.name,
    };

    await message.channel.send(
      LfsMessage({ author: message.author, channel, inviteUrl: invite.url, note, footer, missingPlayers, users }),
    );
  }
  //TODO:–Ω–µ–≥–æ–ª–æ—Å–æ–≤–æ–π –∫–∞–Ω–∞–ª
  // else {
  // const authorDocument = await User.findOne({ discordId: message.author.id });
  // const users = [computeUserPartialFromDocument(message.author.id, authorDocument)];
  // const embed = await message.channel.send(
  //   EmbedLookingForSomeone({
  //     author: {
  //       id: message.author.id,
  //       avatar: message.author.avatar,
  //     },
  //     users,
  //     note: isNoteValid ? note : '',
  //   }),
  // );
  // await embed.react('üëç');
  // }
};

export default LfsResolver;
